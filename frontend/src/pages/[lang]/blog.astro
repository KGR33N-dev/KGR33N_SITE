---
export const prerender = true;
import Layout from '~/layouts/PageLayout.astro';
import { useTranslations } from '~/i18n/utils';
import { languages } from '~/i18n';
import { API_URLS } from '~/config/api';
import Grid from '~/components/blog/Grid.astro';
import Pagination from '~/components/blog/Pagination.astro';
import { convertApiPostToPost } from '~/types/blog';
import type { Post, BlogApiResponse } from '~/types/blog';

export function getStaticPaths() {
  return Object.keys(languages).flatMap(lang => [
    { params: { lang } },
    // Generate pagination paths
    ...Array.from({ length: 5 }, (_, i) => ({ 
      params: { lang, page: String(i + 2) } 
    }))
  ]);
}

const { lang } = Astro.params;
const t = useTranslations(lang as keyof typeof languages);

// Get current page from URL params or query
const currentPage = parseInt(Astro.url.searchParams.get('page') || '1');

// Fetch blog posts from FastAPI
let posts: Post[] = [];
let totalPages = 1;
let error: string | null = null;
let needsClientSideFetch = false; // Flag for client-side loading when build-time fetch fails

try {
  // First try to get all published posts, then filter by available translations
  const apiUrl = API_URLS.getAllPosts({
    page: currentPage,
    per_page: 12,
    published: true,
    sort: 'published_at',
    order: 'desc'
  });
  console.log('ðŸ” Fetching from API (all posts):', apiUrl);
  
  const response = await fetch(apiUrl, {
    // Add timeout for build-time fetch
    signal: AbortSignal.timeout(5000)
  });
  
  if (response.ok) {
    const data: BlogApiResponse = await response.json();
    console.log('ðŸ“Š Raw API response:', data);
    console.log('ðŸ“Š Total posts found:', data.total);
    
    // Filter posts that have translation for current language OR fallback to first available
    const availablePosts = data.items.filter(post => {
      const hasRequestedLang = post.translations?.some(t => t.language_code === lang);
      const hasAnyTranslation = post.translations?.length > 0;
      console.log(`Post ${post.id} (${post.slug}): has ${lang}=${hasRequestedLang}, has any=${hasAnyTranslation}`);
      return hasAnyTranslation; // Show posts that have any translation
    });
    
    console.log('ðŸ“‹ Posts with translations:', availablePosts.length);
    
    // Convert API posts to our Post format with language preference
    posts = availablePosts.map(post => {
      try {
        return convertApiPostToPost(post, lang);
      } catch (conversionError) {
        console.warn(`Failed to convert post ${post.id}:`, conversionError);
        // Try with first available language as fallback
        const firstLang = post.translations?.[0]?.language_code || 'en';
        return convertApiPostToPost(post, firstLang);
      }
    });
    
    totalPages = data.pages;
    
    // Filter only published posts (additional safety check)
    posts = posts.filter(post => post.is_published);
    
    console.log('âœ… Published posts loaded:', posts.length);
    if (posts.length > 0) {
      console.log('ðŸ“‹ First post details:', {
        id: posts[0].id,
        title: posts[0].title,
        currentTitle: posts[0].currentTitle,
        language: posts[0].language,
        is_published: posts[0].is_published,
        permalink: posts[0].permalink,
        available_translations: posts[0].translations?.map(t => t.language_code)
      });
    }
  } else {
    console.error('âŒ API response not OK:', response.status, response.statusText);
    const errorText = await response.text();
    console.error('âŒ Error details:', errorText);
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
} catch (e) {
  console.error('âŒ Error fetching posts during build:', e);
  // Instead of showing error, flag for client-side fetch
  // This allows the page to build even when API is unavailable
  if (import.meta.env.PROD || import.meta.env.MODE === 'production') {
    // In production build, use client-side fetching as fallback
    needsClientSideFetch = true;
    console.log('âš ï¸ Will attempt client-side fetch');
  } else {
    // In dev mode, still show the error for debugging
    error = e instanceof Error ? e.message : 'Unknown error';
  }
}


const metadata = {
  title: currentPage > 1 ? `${t('blog.title')} - ${t('blog.page')} ${currentPage}` : t('blog.title'),
  description: t('blog.description'),
  robots: {
    index: true,
    follow: true,
  },
  openGraph: {
    type: 'website',
    title: t('blog.title'),
    description: t('blog.subtitle'),
  },
};
---

<Layout metadata={metadata}>
  <section class="px-4 md:px-6 py-12 sm:py-16 lg:py-20 mx-auto max-w-7xl">
    <!-- Header -->
    <div class="text-center mb-12">
      <h1 class="text-4xl md:text-5xl font-bold leading-tight mb-4 font-heading">
        {t('blog.title')}
      </h1>
      <p class="text-xl text-muted max-w-3xl mx-auto">
        {t('blog.subtitle')}
      </p>
    </div>

    <!-- Blog Posts Section -->
    {needsClientSideFetch ? (
      <!-- Client-side loading state -->
      <div id="blog-loading-container">
        <div class="text-center py-16" id="blog-loading">
          <div class="animate-pulse max-w-4xl mx-auto">
            <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
              {[1, 2, 3, 4, 5, 6].map(() => (
                <div class="bg-gray-200 dark:bg-gray-700 rounded-lg h-64"></div>
              ))}
            </div>
          </div>
          <p class="text-muted mt-8">{t('blog.loading') || 'Loading posts...'}</p>
        </div>
        
        <!-- Container for dynamically loaded posts -->
        <div id="blog-posts-container" class="hidden"></div>
        
        <!-- Error container (hidden by default) -->
        <div id="blog-error-container" class="hidden text-center py-16">
          <div class="bg-red-50 dark:bg-red-900/20 rounded-lg p-8 max-w-2xl mx-auto">
            <div class="text-red-600 dark:text-red-400 mb-4">
              <svg class="w-16 h-16 mx-auto" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
              </svg>
            </div>
            <h2 class="text-2xl font-bold text-red-800 dark:text-red-200 mb-4">{t('blog.errorTitle')}</h2>
            <p id="blog-error-message" class="text-red-700 dark:text-red-300"></p>
          </div>
        </div>
        
        <!-- No posts container (hidden by default) -->
        <div id="blog-empty-container" class="hidden text-center py-16">
          <div class="bg-blue-50 dark:bg-gray-800 rounded-lg p-8 max-w-2xl mx-auto">
            <div class="text-blue-600 dark:text-blue-400 mb-4">
              <svg class="w-16 h-16 mx-auto" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
              </svg>
            </div>
            <h2 class="text-3xl font-bold text-default mb-4">{t('blog.comingSoon')}</h2>
            <p class="text-lg text-muted">{t('blog.noPostsMessage')}</p>
          </div>
        </div>
      </div>
      
      <script define:vars={{ lang, currentPage, apiBaseUrl: import.meta.env.PUBLIC_API_URL || '' }}>
        // Client-side fetch when build-time fetch failed
        (async function() {
          const loadingEl = document.getElementById('blog-loading');
          const postsContainer = document.getElementById('blog-posts-container');
          const errorContainer = document.getElementById('blog-error-container');
          const errorMessage = document.getElementById('blog-error-message');
          const emptyContainer = document.getElementById('blog-empty-container');
          
          try {
            // Determine API URL - use relative URL in browser for same-origin requests
            // or fall back to window location based detection
            let baseUrl = apiBaseUrl;
            if (!baseUrl || baseUrl === '') {
              // Detect if we're on localhost
              if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                baseUrl = 'http://localhost:8080';
              } else {
                // Production - use relative URL or configured API
                baseUrl = 'https://api.kgr33n.com';
              }
            }
            
            const apiUrl = `${baseUrl}/api/blog/?page=${currentPage}&per_page=12&published=true&sort=published_at&order=desc`;
            console.log('ðŸ” Client-side fetching from:', apiUrl);
            
            const response = await fetch(apiUrl);
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log('ðŸ“Š Client-side response:', data);
            
            // Hide loading
            if (loadingEl) loadingEl.classList.add('hidden');
            
            if (data.items && data.items.length > 0) {
              // Show posts - create simple grid
              if (postsContainer) {
                postsContainer.innerHTML = createPostsGrid(data.items, lang);
                postsContainer.classList.remove('hidden');
              }
            } else {
              // Show empty state
              if (emptyContainer) emptyContainer.classList.remove('hidden');
            }
            
          } catch (err) {
            console.error('âŒ Client-side fetch failed:', err);
            if (loadingEl) loadingEl.classList.add('hidden');
            if (errorContainer) {
              errorContainer.classList.remove('hidden');
              if (errorMessage) errorMessage.textContent = err.message || 'Failed to load posts';
            }
          }
          
          function createPostsGrid(posts, currentLang) {
            const grid = posts.map(post => {
              // Get translation for current language or first available
              const translation = post.translations?.find(t => t.language_code === currentLang) 
                               || post.translations?.[0];
              if (!translation) return '';
              
              const title = translation.title || 'Untitled';
              const excerpt = translation.excerpt || translation.content?.substring(0, 150) + '...' || '';
              const imageUrl = post.featured_image || '/images/default-blog.jpg';
              const postUrl = `/${currentLang}/blog/${post.slug}`;
              
              return `
                <article class="bg-white dark:bg-gray-800 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition-shadow duration-300">
                  <a href="${postUrl}" class="block">
                    <div class="aspect-video bg-gray-200 dark:bg-gray-700 overflow-hidden">
                      <img 
                        src="${imageUrl}" 
                        alt="${title}"
                        class="w-full h-full object-cover hover:scale-105 transition-transform duration-300"
                        loading="lazy"
                        onerror="this.src='/images/default-blog.jpg'"
                      />
                    </div>
                    <div class="p-6">
                      <h3 class="text-xl font-bold text-gray-900 dark:text-white mb-2 line-clamp-2">
                        ${title}
                      </h3>
                      <p class="text-gray-600 dark:text-gray-300 text-sm line-clamp-3">
                        ${excerpt}
                      </p>
                      <div class="mt-4 flex items-center text-sm text-gray-500 dark:text-gray-400">
                        <span>${post.author || 'KGR33N'}</span>
                        ${post.published_at ? `<span class="mx-2">â€¢</span><span>${new Date(post.published_at).toLocaleDateString()}</span>` : ''}
                      </div>
                    </div>
                  </a>
                </article>
              `;
            }).join('');
            
            return `<div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6">${grid}</div>`;
          }
        })();
      </script>
    ) : error ? (
      <div class="text-center py-16">
        <div class="bg-red-50 dark:bg-red-900/20 rounded-lg p-8 max-w-2xl mx-auto">
          <div class="text-red-600 dark:text-red-400 mb-4">
            <svg class="w-16 h-16 mx-auto" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
            </svg>
          </div>
          <h2 class="text-2xl font-bold text-red-800 dark:text-red-200 mb-4">{t('blog.errorTitle')}</h2>
          <p class="text-red-700 dark:text-red-300">{error}</p>
        </div>
      </div>
    ) : posts.length === 0 ? (
      <div class="text-center py-16">
        <div class="bg-blue-50 dark:bg-gray-800 rounded-lg p-8 max-w-2xl mx-auto">
          <div class="text-blue-600 dark:text-blue-400 mb-4">
            <svg class="w-16 h-16 mx-auto" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
            </svg>
          </div>
          <h2 class="text-3xl font-bold text-default mb-4">{t('blog.comingSoon')}</h2>
          <p class="text-lg text-muted">{t('blog.noPostsMessage')}</p>
        </div>
      </div>
    ) : (
      <>
        <!-- Posts Grid -->
        <Grid posts={posts} lang={lang} />
        
        <!-- Pagination -->
        {totalPages > 1 && (
          <div class="mt-12">
            <Pagination 
              currentPage={currentPage}
              totalPages={totalPages}
              baseUrl={`/${lang}/blog`}
            />
          </div>
        )}
      </>
    )}
  </section>
</Layout>